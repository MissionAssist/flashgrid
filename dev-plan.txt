
Need to tweak what happens under this, to get a grid:
  self._showQuestion()
Maybe this too?
  self._initWeb()

-----
reviewer.py
  Make use of the existing "showQuestion" hook in _showQuestion() to pop up a grid of card backs 
  a half-second AFTER Anki has finished displaying the main card's front. (Is this modal dialog acceptable?)
  
  Create our own HTML table grid, then render each grid cell using _showAnswer().
  main.py : self.web
  webview.py : AnkiWebView(QWebView) Note that we need to handle clicks, and by making each cell a link, we can do just 
  like AnkiWebView(QWebView)__init__() does:
    QWebPage.DelegateAllLinks)
    self.setLinkHandler()
  The links could maybe just be "1", "2", etc. Only the correct one should close the modal dialog, but we'd
  also have a "Done (Esc)" button
  Maybe should use this too: self.page().mainFrame().evaluateJavaScript(js)
  
  To fill the grid, we shouldn't pop like getCard() but rather peek into the cardQueue
  See sched.py : self.mw.col.sched.getCard()
  
  Grab the flak cards directly from the database. We can't rely on peeking into _lrnQueue; it may not have enough.
  NEED TO refactor out the SQL from _fillLrn() in sched.py.
  
  (Maybe make use of the "showAnswer" hook in _showAnswer() to make sure our popup got closed?)
  
cards.py
  take a look at q() and a(), both of which call _getQA, which gets HTML from _renderQA (in collection.py)
 
sound.py
  Eventually, we'll want to block playFromText() from playing audio for the grid.
reviewer.py
  Maybe block correct() as well, since they're clicking the grid, not typing

