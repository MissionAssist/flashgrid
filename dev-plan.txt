
Need to tweak what happens under this, to get a grid:
  self._showQuestion()
Maybe this too?
  self._initWeb()

-----
reviewer.py
  Make use of the existing "showQuestion" hook in _showQuestion() to pop up a grid of card backs 
  a half-second AFTER Anki has finished displaying the main card's front. (Is this modal dialog acceptable?)
  
  Create our own HTML table grid, then render each grid cell using _showAnswer().
  main.py : self.web
  webview.py : AnkiWebView(QWebView) Note that we need to handle clicks, and by making each cell a link, we can do just 
  like AnkiWebView(QWebView)__init__() does:
    QWebPage.DelegateAllLinks)
    self.setLinkHandler()
  The links could maybe just be "1", "2", etc. Only the correct one should close the modal dialog, but we'd
  also have a "Done (Esc)" button
  Maybe should use this too: self.page().mainFrame().evaluateJavaScript(js)
  
  
  
  To fill the grid, we shouldn't pop like getCard() but rather peek into the cardQueue
  See sched.py : self.mw.col.sched.getCard()
  
  Grab the flak cards directly from the database. We can't rely on peeking into _lrnQueue; it may not have enough.
  NEED TO refactor out the SQL from _fillLrn() in sched.py.
  
  OR, use Card.did (or DeckManager.current()) to get the deck, then get a collection of cards from that deck?
  
deckName = mw.col.decks.current()['name']
cardIds = mw.col.findCards("-is:suspended deck:%s" % deckName)
card = mw.col.getCard(cardIds[0])
pp(card)


  
a = mw.col.findCards("-is:suspended deck:indonesian-lift-dictionary-Orig")
b = mw.col.decks.current()['id']
c = mw.col.findCards("-is:suspended deck:%s" % b)
print mw.col.findCards("id:%s" % "1414837001874L")
  
  (Maybe make use of the "showAnswer" hook in _showAnswer() to make sure our popup got closed?)

    mw.col. findCards(self, query):
	
	query: "-is:suspended deck:XX"
  
  
    def _fillCramQueue(self):
        if self.revCount and not self.revQueue:
            self.revQueue = self.s.all(self.cardLimit(
                self.activeCramTags, "", """
select id, factId from cards c
where type between 0 and 2
order by %s
limit %s""" % (self.cramOrder, self.queueLimit)))
            self.revQueue.reverse()

	sched: def _fillDyn(self, deck):
			
	
    def findCardsWhere(self, query):
	def findCardsMatchingFilters(self, filters):
	def _findCards(self, query):	
			
  Or to grab from the queue, maybe: Deck.spacedCards[][]			
  
cards.py
  take a look at q() and a(), both of which call _getQA, which gets HTML from _renderQA (in collection.py)
 
sound.py
  Eventually, we'll want to block playFromText() from playing audio for the grid.
reviewer.py
  Maybe block correct() as well, since they're clicking the grid, not typing

